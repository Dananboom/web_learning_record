# 1 是什么

* 就是是脚本语言，脚本需要解析器，在浏览器里面的js，浏览器是环境，提供了dom对象等等，而独立运行的js，node是解析器
* 运行在nodejs里面的js的作用是**操作文件**或者**搭建web服务器**，所以有`http`或者是`fs`内置对象

# 2 有什么用

* nodejs生来是为了做web服务器，要求语言有良好的**事件支持机制**和**异步IO**

# 3 模块

编写代码大的程序的时候会将代码**模块化**

js的模块化大概有两种常用的 commonjs和es module

## 3.1 .1变量污染

html里可以引进script，那两个js变量会冲突，如果两个文件都用一个名字做变量就冲入了。一个代码的变量入侵另一个变量，这种比多人开发引用开源的库，难道还看人家用啥变量嘛

解决方法，可以用函数作用域把他们给隔开，作用域隔离，假如别人引用了这个文件，只会暴露有限的名字，别的访问不了

```js
const $ = function() {
	function create () {
        // ...
    }
    
    function get () {
        // ...
    }
    return creat
}
//对外只暴露一个符号，内部所有函数变量都被包起来了，不对外暴露，减少变量污染
```

还可以命名空间

```js
const fs = {
    readfile() {
        // ...
    }, 
    writefile() {
		// ...
    }
}
//比如fs下面有汗多方法，他们都挂在fs下面
//如果全都在全局，就要暴露很多方法，占用很多名字，所以都挂在一个对象上
```

还有中方法是命名规范，比如xx_xx，c语言很多项目都是命名规范，但是命名规范不能解决根本的问题只是约束，还增加了开发者的心智负担

然后命名空间和函数都可以优化变量污染，但是也只是把n个污染降低到1而不是0

有更好的解决方法是**模块化**

### 3.2.1 require

在当前的模块加载别的模块

### 3.2.2 exports

导出模块的公有方法和属性

### 3.2.3 module

替换当前模块的导出对象

### 3.2.4 nodejs里面使用commonjs模块

[CommonJs, AMD/RequireJs,CMD/seajs, UMD, webpack #32](CommonJs, AMD/RequireJs,CMD/seajs, UMD, webpack #32)

commonjs是同步执行的，最初是服务服务端，所以在浏览器里就会有问题，所以有了AMD或者是CMD

### 3.2.5 二进制模块